import json
import shutil
import subprocess
import tempfile
from pathlib import Path

from utils import compare_dict_list


class TestScanner:
    SARIF_OUTPUT = json.loads(
        """{"$schema": "https://json.schemastore.org/sarif-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "CVE Binary Tool", "semanticVersion": "3.2.2dev0", "rules": [{"id": "@cve-bin-tool/html_pdf_sbom_report", "name": "HTML, PDF & SBOM Scan reports by CVE Binary Tool", "shortDescription": {"text": "HTML, PDF & SBOM Scan reports by CVE Binary Tool"}, "fullDescription": {"text": "HTML & PDF reports provide detailed insight of the known vulnerabilities (CVEs) found. The generated Software Bill of Materials (SBOM) file gives you a list of all the components found and scanned by cve-bin-tool. This may not represent everything you know to to be in your software, only what we were able to identify. These results get automatically updated each time the CVE Binary Tool GitHub Action runs. You can disable this by dismissing the alert, then you won't receive any further HTML/PDF/SBOM reports."}, "defaultConfiguration": {"level": "warning"}, "properties": {"tags": ["scan reports"], "precision": "medium"}}, {"id": "61666a02", "shortDescription": {"text": "Vulnerable component avahi_0.6.25 found in avahi-0.6.25-17.el6.x86_64.rpm.tar.gz:avahi_0.6.25"}, "help": {"text": "", "markdown": "**Basic information about `CVE-2010-2244`:**<br/>The AvahiDnsPacket function in avahi-core/socket.c in avahi-daemon in Avahi 0.6.16 and 0.6.25 allows remote attackers to cause a denial of service (assertion failure and daemon exit) via a DNS packet with an invalid checksum followed by a DNS packet with a valid checksum, a different vulnerability than CVE-2008-5081.<br/><br/>**Basic information about `CVE-2011-1002`:**<br/>avahi-core/socket.c in avahi-daemon in Avahi before 0.6.29 allows remote attackers to cause a denial of service (infinite loop) via an empty mDNS (1) IPv4 or (2) IPv6 UDP packet to port 5353. NOTE: this vulnerability exists because of an incorrect fix for CVE-2010-2244.<br/><br/>**Basic information about `CVE-2017-6519`:**<br/>avahi-daemon in Avahi through 0.6.32 and 0.7 inadvertently responds to IPv6 unicast queries with source addresses that are not on-link, which allows remote attackers to cause a denial of service (traffic amplification) and may cause information leakage by obtaining potentially sensitive  information from the responding device via port-5353 UDP packets.  NOTE: this may overlap CVE-2015-2809.<br/><br/>**Basic information about `CVE-2021-26720`:**<br/>avahi-daemon-check-dns.sh in the Debian avahi package through 0.8-4 is executed as root via /etc/network/if-up.d/avahi-daemon, and allows a local attacker to cause a denial of service or create arbitrary empty files via a symlink attack on files under /run/avahi-daemon. NOTE: this only affects the packaging for Debian GNU/Linux (used indirectly by SUSE), not the upstream Avahi product.<br/><br/>**Basic information about `CVE-2021-3468`:**<br/>A flaw was found in avahi in versions 0.6 up to 0.8. The event used to signal the termination of the client connection on the avahi Unix socket is not correctly handled in the client_work function, allowing a local attacker to trigger an infinite loop. The highest threat from this vulnerability is to the availability of the avahi service, which becomes unresponsive after this flaw is triggered."}, "properties": {"tags": ["vulnerablity"], "precision": "high", "security-severity": "9.1"}}]}}, "results": [{"ruleId": "@cve-bin-tool/html_pdf_sbom_report", "message": {"text": "Here is the HTML, PDF & SBOM Scan Reports: https://github.com/REPOSITORY/actions/runs/RUNID. To download the reports, first click on the link and scroll down to the 'Artifacts' section then click on 'cve_reports'."}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "*"}}}]}, {"ruleId": "61666a02", "message": {"text": "Product Name: avahi<br/>Version: 0.6.25<br/><br/>CVE ID: CVE-2010-2244<br/>CVE Score: 4.3<br/>CVE Severity: MEDIUM<br/>Patched Version: v0.6.26-1<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2010-2244<br/><br/>CVE ID: CVE-2011-1002<br/>CVE Score: 5<br/>CVE Severity: MEDIUM<br/>Patched Version: v0.6.28-4<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2011-1002<br/><br/>CVE ID: CVE-2017-6519<br/>CVE Score: 9.1<br/>CVE Severity: CRITICAL<br/>Patched Version: v0.7-5<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2017-6519<br/><br/>CVE ID: CVE-2021-26720<br/>CVE Score: 7.8<br/>CVE Severity: HIGH<br/>Patched Version: v0.8-4<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2021-26720<br/><br/>CVE ID: CVE-2021-3468<br/>CVE Score: 5.5<br/>CVE Severity: MEDIUM<br/>Patched Version: v0.8-5+deb11u2<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2021-3468"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "avahi-0.6.25-17.el6.x86_64.rpm.tar.gz_avahi_0.6.25"}}}]}]}]}"""
    )
    TEST_DIR = Path("test")
    VULNERABLE_FILE = (
        TEST_DIR / "condensed-downloads" / "avahi-0.6.25-17.el6.x86_64.rpm.tar.gz"
    )
    SCANNER = TEST_DIR.parent / "src" / "scanner.py"
    BUILD_DIR = TEST_DIR / "build"

    @classmethod
    def setup_class(cls):
        cls.tmp_dir = Path(tempfile.gettempdir()) / "cve-bin-tool-scanner-sarif"
        cls.tmp_dir.mkdir()
        cls.tmp_vulnerable_file = cls.tmp_dir / cls.VULNERABLE_FILE.name
        shutil.copy(cls.VULNERABLE_FILE, cls.tmp_vulnerable_file)

    @classmethod
    def teardown_class(cls):
        shutil.rmtree(cls.tmp_dir)

    def test_scanner(self):
        subprocess.run(
            [
                "python",
                str(self.SCANNER),
                str(self.tmp_vulnerable_file),
                "--repo",
                "REPOSITORY",
                "--run-id",
                "RUNID",
                "--sarif-output",
                str(self.tmp_dir / "output.sarif"),
                "--html-pdf-output",
                str(self.tmp_dir / "report"),
                "--sbom-output",
                str(self.tmp_dir / "SBOM"),
            ]
        )
        with open(self.tmp_dir / "output.sarif") as fd:
            sarif_output_json = json.loads(fd.read())
            assert sarif_output_json["$schema"] == self.SARIF_OUTPUT["$schema"]
            assert sarif_output_json["version"] == self.SARIF_OUTPUT["version"]
            assert (
                sarif_output_json["runs"][0]["tool"]["driver"]["name"]
                == self.SARIF_OUTPUT["runs"][0]["tool"]["driver"]["name"]
            )
            assert compare_dict_list(
                self.SARIF_OUTPUT["runs"][0]["tool"]["driver"]["rules"],
                sarif_output_json["runs"][0]["tool"]["driver"]["rules"],
            )
            assert compare_dict_list(
                self.SARIF_OUTPUT["runs"][0]["results"],
                sarif_output_json["runs"][0]["results"],
            )
        assert (self.tmp_dir / "report.html").exists() and (
            self.tmp_dir / "report.pdf"
        ).exists()

    def test_build_command(self):
        build_process = subprocess.run(
            [
                "python",
                str(self.SCANNER),
                str(self.tmp_vulnerable_file),
                "--repo",
                "REPOSITORY",
                "--run-id",
                "RUNID",
                "--sarif-output",
                str(self.tmp_dir / "output.sarif"),
                "--html-pdf-output",
                str(self.tmp_dir / "report"),
                "--sbom-output",
                str(self.tmp_dir / "SBOM"),
                "--build-command",
                f"gcc {self.BUILD_DIR / 'noerr.c'} -o {self.tmp_dir / 'noerr'} && echo 'BUILD PROCESS SUCCEEDED!'",
            ],
            text=True,
            capture_output=True,
        )
        assert (
            build_process.stdout.find("BUILD PROCESS SUCCEEDED!") != -1
        )  # to make sure build command is getting called
        assert build_process.returncode == 0

        build_with_err = subprocess.run(
            [
                "python",
                str(self.SCANNER),
                str(self.tmp_vulnerable_file),
                "--repo",
                "REPOSITORY",
                "--run-id",
                "RUNID",
                "--sarif-output",
                str(self.tmp_dir / "output.sarif"),
                "--html-pdf-output",
                str(self.tmp_dir / "report"),
                "--sbom-output",
                str(self.tmp_dir / "SBOM"),
                "--build-command",
                f"gcc {self.BUILD_DIR / 'err.c'} -o {self.tmp_dir / 'err'} -W -Wall -Werror",
            ],
            text=True,
            capture_output=True,
        )
        assert (
            build_with_err.stdout.find(
                "error: implicit declaration of function ‘printf’ [-Werror=implicit-function-declaration]"
            )
            != -1
        )  # to make sure build command is getting called
        assert build_with_err.returncode == 1
