import shutil
import subprocess
import tempfile
from pathlib import Path


class TestScanner:
    SARIF_OUTPUT = """{"$schema": "https://json.schemastore.org/sarif-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "CVE Binary Tool", "semanticVersion": "3.2.2dev0", "rules": [{"id": "@cve-bin-tool/html_pdf_report", "name": "HTML & PDF Scan reports by CVE Binary Tool", "shortDescription": {"text": "HTML & PDF Scan reports by CVE Binary Tool"}, "fullDescription": {"text": "HTML & PDF reports provide detailed insight of the CVEs and make them easy to track. These results get automatically updated eachtime when the CVE Binary Tool GitHub Action runs. You can disable this just by dismissing the alert, then you won't receive any further HTML/PDF reports."}, "defaultConfiguration": {"level": "warning"}, "properties": {"tags": ["scan reports"], "precision": "medium"}}, {"id": "e41ccb5a", "shortDescription": {"text": "Vulnerable components found in avahi-0.6.25-17.el6.x86_64.rpm.tar.gz"}, "help": {"text": "", "markdown": "**Basic information about `CVE-2010-2244`:**<br/>The AvahiDnsPacket function in avahi-core/socket.c in avahi-daemon in Avahi 0.6.16 and 0.6.25 allows remote attackers to cause a denial of service (assertion failure and daemon exit) via a DNS packet with an invalid checksum followed by a DNS packet with a valid checksum, a different vulnerability than CVE-2008-5081.<br/><br/>**Basic information about `CVE-2011-1002`:**<br/>avahi-core/socket.c in avahi-daemon in Avahi before 0.6.29 allows remote attackers to cause a denial of service (infinite loop) via an empty mDNS (1) IPv4 or (2) IPv6 UDP packet to port 5353. NOTE: this vulnerability exists because of an incorrect fix for CVE-2010-2244.<br/><br/>**Basic information about `CVE-2017-6519`:**<br/>avahi-daemon in Avahi through 0.6.32 and 0.7 inadvertently responds to IPv6 unicast queries with source addresses that are not on-link, which allows remote attackers to cause a denial of service (traffic amplification) and may cause information leakage by obtaining potentially sensitive  information from the responding device via port-5353 UDP packets.  NOTE: this may overlap CVE-2015-2809.<br/><br/>**Basic information about `CVE-2021-3468`:**<br/>A flaw was found in avahi in versions 0.6 up to 0.8. The event used to signal the termination of the client connection on the avahi Unix socket is not correctly handled in the client_work function, allowing a local attacker to trigger an infinite loop. The highest threat from this vulnerability is to the availability of the avahi service, which becomes unresponsive after this flaw is triggered.<br/><br/>**Basic information about `CVE-2021-3502`:**<br/>A flaw was found in avahi 0.8-5. A reachable assertion is present in avahi_s_host_name_resolver_start function allowing a local attacker to crash the avahi service by requesting hostname resolutions through the avahi socket or dbus methods for invalid hostnames. The highest threat from this vulnerability is to the service availability.<br/><br/>**Basic information about `DLA-3047-1`:**<br/>avahi - security update<br/><br/>**Basic information about `DLA-3414-1`:**<br/>avahi - security update<br/><br/>**Basic information about `DLA-3466-1`:**<br/>avahi - security update<br/><br/>**Basic information about `DSA-2174-1`:**<br/>avahi - denial of service<br/><br/>"}, "properties": {"tags": ["vulnerablity"], "precision": "high", "security-severity": "9.1"}}]}}, "results": [{"ruleId": "@cve-bin-tool/html_pdf_report", "message": {"text": "Here is the HTML & PDF Scan Reports: https://github.com/REPOSITORY/actions/runs/RUNID. To download the reports, first click on the link and scroll down to the 'Artifacts' section then click on 'cve_reports'."}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "*"}}}]}, {"ruleId": "e41ccb5a", "message": {"text": "Product Name: avahi<br/>Version: 0.6.25<br/><br/>CVE ID: CVE-2010-2244<br/>CVE Score: 4.3<br/>CVE Severity: MEDIUM<br/>Patched Version: v0.6.26-1<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2010-2244<br/><br/>CVE ID: CVE-2011-1002<br/>CVE Score: 5<br/>CVE Severity: MEDIUM<br/>Patched Version: v0.6.28-4<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2011-1002<br/><br/>CVE ID: CVE-2017-6519<br/>CVE Score: 9.1<br/>CVE Severity: CRITICAL<br/>Patched Version: v0.7-5<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2017-6519<br/><br/>CVE ID: CVE-2021-3468<br/>CVE Score: 5.5<br/>CVE Severity: MEDIUM<br/>Patched Version: v0.8-5+deb11u2<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2021-3468<br/><br/>CVE ID: CVE-2021-3502<br/>CVE Score: 5.5<br/>CVE Severity: MEDIUM<br/>Patched Version: v0.8-5+deb11u1<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2021-3502<br/><br/>CVE ID: DLA-3047-1<br/>CVE Score: unknown<br/>CVE Severity: UNKNOWN<br/>CVE Remark: NewFound<br/>Source: OSV<br/><br/>CVE ID: DLA-3414-1<br/>CVE Score: unknown<br/>CVE Severity: UNKNOWN<br/>CVE Remark: NewFound<br/>Source: OSV<br/><br/>CVE ID: DLA-3466-1<br/>CVE Score: unknown<br/>CVE Severity: UNKNOWN<br/>CVE Remark: NewFound<br/>Source: OSV<br/><br/>CVE ID: DSA-2174-1<br/>CVE Score: unknown<br/>CVE Severity: UNKNOWN<br/>CVE Remark: NewFound<br/>Source: OSV<br/><br/>"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "avahi-0.6.25-17.el6.x86_64.rpm.tar.gz"}}}]}]}]}"""
    TEST_DIR = Path("test")
    VULNERABLE_FILE = (
        TEST_DIR / "condensed-downloads" / "avahi-0.6.25-17.el6.x86_64.rpm.tar.gz"
    )
    SCANNER = TEST_DIR.parent / "src" / "scanner.py"

    @classmethod
    def setup_class(cls):
        cls.tmp_dir = Path(tempfile.gettempdir()) / "cve-bin-tool-scanner-sarif"
        cls.tmp_dir.mkdir()
        cls.tmp_vulnerable_file = cls.tmp_dir / cls.VULNERABLE_FILE.name
        shutil.copy(cls.VULNERABLE_FILE, cls.tmp_vulnerable_file)

    @classmethod
    def teardown_class(cls):
        shutil.rmtree(cls.tmp_dir)

    def test_scanner(self):
        subprocess.run(
            [
                "python",
                str(self.SCANNER),
                str(self.tmp_vulnerable_file),
                "--repo",
                "REPOSITORY",
                "--run-id",
                "RUNID",
                "--sarif-output",
                str(self.tmp_dir / "output.sarif"),
                "--html-pdf-output",
                str(self.tmp_dir / "report"),
            ]
        )
        with open(self.tmp_dir / "output.sarif") as fd:
            assert fd.read() == self.SARIF_OUTPUT
        assert (self.tmp_dir / "report.html").exists() and (
            self.tmp_dir / "report.pdf"
        ).exists()
