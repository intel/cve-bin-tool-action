import json
import shutil
import subprocess
import tempfile
from pathlib import Path

from utils import compare_dict_list


class TestScanner:
    SARIF_OUTPUT = json.loads(
        """{"$schema": "https://json.schemastore.org/sarif-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "CVE Binary Tool", "semanticVersion": "3.2.2dev0", "rules": [{"id": "@cve-bin-tool/html_pdf_report", "name": "HTML & PDF Scan reports by CVE Binary Tool", "shortDescription": {"text": "HTML & PDF Scan reports by CVE Binary Tool"}, "fullDescription": {"text": "HTML & PDF reports provide detailed insight of the CVEs and make them easy to track. These results get automatically updated eachtime when the CVE Binary Tool GitHub Action runs. You can disable this just by dismissing the alert, then you won't receive any further HTML/PDF reports."}, "defaultConfiguration": {"level": "warning"}, "properties": {"tags": ["scan reports"], "precision": "medium"}}, {"id": "e41ccb5a", "shortDescription": {"text": "Vulnerable components found in avahi-0.6.25-17.el6.x86_64.rpm.tar.gz"}, "help": {"text": "", "markdown": "**Basic information about `CVE-2010-2244`:**<br/>The AvahiDnsPacket function in avahi-core/socket.c in avahi-daemon in Avahi 0.6.16 and 0.6.25 allows remote attackers to cause a denial of service (assertion failure and daemon exit) via a DNS packet with an invalid checksum followed by a DNS packet with a valid checksum, a different vulnerability than CVE-2008-5081.<br/><br/>**Basic information about `CVE-2011-1002`:**<br/>avahi-core/socket.c in avahi-daemon in Avahi before 0.6.29 allows remote attackers to cause a denial of service (infinite loop) via an empty mDNS (1) IPv4 or (2) IPv6 UDP packet to port 5353. NOTE: this vulnerability exists because of an incorrect fix for CVE-2010-2244.<br/><br/>**Basic information about `CVE-2017-6519`:**<br/>avahi-daemon in Avahi through 0.6.32 and 0.7 inadvertently responds to IPv6 unicast queries with source addresses that are not on-link, which allows remote attackers to cause a denial of service (traffic amplification) and may cause information leakage by obtaining potentially sensitive  information from the responding device via port-5353 UDP packets.  NOTE: this may overlap CVE-2015-2809.<br/><br/>**Basic information about `CVE-2021-26720`:**<br/>avahi-daemon-check-dns.sh in the Debian avahi package through 0.8-4 is executed as root via /etc/network/if-up.d/avahi-daemon, and allows a local attacker to cause a denial of service or create arbitrary empty files via a symlink attack on files under /run/avahi-daemon. NOTE: this only affects the packaging for Debian GNU/Linux (used indirectly by SUSE), not the upstream Avahi product.<br/><br/>**Basic information about `CVE-2021-3468`:**<br/>A flaw was found in avahi in versions 0.6 up to 0.8. The event used to signal the termination of the client connection on the avahi Unix socket is not correctly handled in the client_work function, allowing a local attacker to trigger an infinite loop. The highest threat from this vulnerability is to the availability of the avahi service, which becomes unresponsive after this flaw is triggered.<br/><br/>"}, "properties": {"tags": ["vulnerablity"], "precision": "high", "security-severity": "9.1"}}]}}, "results": [{"ruleId": "@cve-bin-tool/html_pdf_report", "message": {"text": "Here is the HTML & PDF Scan Reports: https://github.com/REPOSITORY/actions/runs/RUNID. To download the reports, first click on the link and scroll down to the 'Artifacts' section then click on 'cve_reports'."}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "*"}}}]}, {"ruleId": "e41ccb5a", "message": {"text": "Product Name: avahi<br/>Version: 0.6.25<br/><br/>CVE ID: CVE-2010-2244<br/>CVE Score: 4.3<br/>CVE Severity: MEDIUM<br/>Patched Version: v0.6.26-1<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2010-2244<br/><br/>CVE ID: CVE-2011-1002<br/>CVE Score: 5<br/>CVE Severity: MEDIUM<br/>Patched Version: v0.6.28-4<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2011-1002<br/><br/>CVE ID: CVE-2017-6519<br/>CVE Score: 9.1<br/>CVE Severity: CRITICAL<br/>Patched Version: v0.7-5<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2017-6519<br/><br/>CVE ID: CVE-2021-26720<br/>CVE Score: 7.8<br/>CVE Severity: HIGH<br/>Patched Version: v0.8-4<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2021-26720<br/><br/>CVE ID: CVE-2021-3468<br/>CVE Score: 5.5<br/>CVE Severity: MEDIUM<br/>Patched Version: v0.8-5+deb11u2<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2021-3468<br/><br/>"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "avahi-0.6.25-17.el6.x86_64.rpm.tar.gz"}}}]}]}]}"""
    )
    TEST_DIR = Path("test")
    VULNERABLE_FILE = (
        TEST_DIR / "condensed-downloads" / "avahi-0.6.25-17.el6.x86_64.rpm.tar.gz"
    )
    SCANNER = TEST_DIR.parent / "src" / "scanner.py"

    @classmethod
    def setup_class(cls):
        cls.tmp_dir = Path(tempfile.gettempdir()) / "cve-bin-tool-scanner-sarif"
        cls.tmp_dir.mkdir()
        cls.tmp_vulnerable_file = cls.tmp_dir / cls.VULNERABLE_FILE.name
        shutil.copy(cls.VULNERABLE_FILE, cls.tmp_vulnerable_file)

    @classmethod
    def teardown_class(cls):
        shutil.rmtree(cls.tmp_dir)

    def test_scanner(self):
        subprocess.run(
            [
                "python",
                str(self.SCANNER),
                str(self.tmp_vulnerable_file),
                "--repo",
                "REPOSITORY",
                "--run-id",
                "RUNID",
                "--sarif-output",
                str(self.tmp_dir / "output.sarif"),
                "--html-pdf-output",
                str(self.tmp_dir / "report"),
            ]
        )
        with open(self.tmp_dir / "output.sarif") as fd:
            sarif_output_json = json.loads(fd.read())
            assert sarif_output_json["$schema"] == self.SARIF_OUTPUT["$schema"]
            assert sarif_output_json["version"] == self.SARIF_OUTPUT["version"]
            assert (
                sarif_output_json["runs"][0]["tool"]["driver"]["name"]
                == self.SARIF_OUTPUT["runs"][0]["tool"]["driver"]["name"]
            )
            assert compare_dict_list(
                self.SARIF_OUTPUT["runs"][0]["tool"]["driver"]["rules"],
                sarif_output_json["runs"][0]["tool"]["driver"]["rules"],
            )
            assert compare_dict_list(
                self.SARIF_OUTPUT["runs"][0]["results"],
                sarif_output_json["runs"][0]["results"],
            )
        assert (self.tmp_dir / "report.html").exists() and (
            self.tmp_dir / "report.pdf"
        ).exists()
