import importlib.util
import json
import shutil
import tempfile
from pathlib import Path

from utils import compare_dict_list

generate_sarif_path = Path("src") / "generate_sarif.py"
generate_sarif_spec = importlib.util.spec_from_file_location(
    "generate_sarif", generate_sarif_path
)
if generate_sarif_spec is not None:
    generate_sarif = importlib.util.module_from_spec(generate_sarif_spec)
    if generate_sarif_spec.loader is not None:
        generate_sarif_spec.loader.exec_module(generate_sarif)


class TestGenerateSarif:
    NO_CVE_SARIF_OUTPUT = json.loads(
        """{"$schema": "https://json.schemastore.org/sarif-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "CVE Binary Tool", "semanticVersion": "3.2.2dev0", "rules": [{"id": "@cve-bin-tool/html_pdf_sbom_report", "name": "HTML, PDF & SBOM Scan reports by CVE Binary Tool", "shortDescription": {"text": "HTML, PDF & SBOM Scan reports by CVE Binary Tool"}, "fullDescription": {"text": "HTML & PDF reports provide detailed insight of the known vulnerabilities (CVEs) found. The generated Software Bill of Materials (SBOM) file gives you a list of all the components found and scanned by cve-bin-tool. This may not represent everything you know to to be in your software, only what we were able to identify. These results get automatically updated each time the CVE Binary Tool GitHub Action runs. You can disable this by dismissing the alert, then you won't receive any further HTML/PDF/SBOM reports."}, "defaultConfiguration": {"level": "warning"}, "properties": {"tags": ["scan reports"], "precision": "medium"}}]}}, "results": []}]}"""
    )
    WITH_CVE_SARIF_OUTPUT = json.loads(
        """{"$schema": "https://json.schemastore.org/sarif-2.1.0.json", "version": "2.1.0", "runs": [{"tool": {"driver": {"name": "CVE Binary Tool", "semanticVersion": "3.2.2dev0", "rules": [{"id": "@cve-bin-tool/html_pdf_sbom_report", "name": "HTML, PDF & SBOM Scan reports by CVE Binary Tool", "shortDescription": {"text": "HTML, PDF & SBOM Scan reports by CVE Binary Tool"}, "fullDescription": {"text": "HTML & PDF reports provide detailed insight of the known vulnerabilities (CVEs) found. The generated Software Bill of Materials (SBOM) file gives you a list of all the components found and scanned by cve-bin-tool. This may not represent everything you know to to be in your software, only what we were able to identify. These results get automatically updated each time the CVE Binary Tool GitHub Action runs. You can disable this by dismissing the alert, then you won't receive any further HTML/PDF/SBOM reports."}, "defaultConfiguration": {"level": "warning"}, "properties": {"tags": ["scan reports"], "precision": "medium"}}, {"id": "a0b76f86", "shortDescription": {"text": "Vulnerable component avahi_0.6.25 found in avahi-0.6.25-17.el6.x86_64.rpm.tar.gz"}, "help": {"text": "", "markdown": "**Basic information about `CVE-2010-2244`:**<br/>The AvahiDnsPacket function in avahi-core/socket.c in avahi-daemon in Avahi 0.6.16 and 0.6.25 allows remote attackers to cause a denial of service (assertion failure and daemon exit) via a DNS packet with an invalid checksum followed by a DNS packet with a valid checksum, a different vulnerability than CVE-2008-5081.<br/><br/>**Basic information about `CVE-2011-1002`:**<br/>avahi-core/socket.c in avahi-daemon in Avahi before 0.6.29 allows remote attackers to cause a denial of service (infinite loop) via an empty mDNS (1) IPv4 or (2) IPv6 UDP packet to port 5353. NOTE: this vulnerability exists because of an incorrect fix for CVE-2010-2244.<br/><br/>**Basic information about `CVE-2017-6519`:**<br/>avahi-daemon in Avahi through 0.6.32 and 0.7 inadvertently responds to IPv6 unicast queries with source addresses that are not on-link, which allows remote attackers to cause a denial of service (traffic amplification) and may cause information leakage by obtaining potentially sensitive  information from the responding device via port-5353 UDP packets.  NOTE: this may overlap CVE-2015-2809.<br/><br/>**Basic information about `CVE-2021-3468`:**<br/>A flaw was found in avahi in versions 0.6 up to 0.8. The event used to signal the termination of the client connection on the avahi Unix socket is not correctly handled in the client_work function, allowing a local attacker to trigger an infinite loop. The highest threat from this vulnerability is to the availability of the avahi service, which becomes unresponsive after this flaw is triggered.<br/><br/>**Basic information about `CVE-2021-3502`:**<br/>A flaw was found in avahi 0.8-5. A reachable assertion is present in avahi_s_host_name_resolver_start function allowing a local attacker to crash the avahi service by requesting hostname resolutions through the avahi socket or dbus methods for invalid hostnames. The highest threat from this vulnerability is to the service availability.<br/><br/>**Basic information about `DLA-3047-1`:**<br/>avahi - security update<br/><br/>**Basic information about `DLA-3414-1`:**<br/>avahi - security update<br/><br/>**Basic information about `DLA-3466-1`:**<br/>avahi - security update<br/><br/>**Basic information about `DSA-2174-1`:**<br/>avahi - denial of service"}, "properties": {"tags": ["vulnerablity"], "precision": "high", "security-severity": "9.1"}}]}}, "results": [{"ruleId": "@cve-bin-tool/html_pdf_sbom_report", "message": {"text": "Here is the HTML, PDF & SBOM Scan Reports: https://github.com/repository/actions/runs/1. To download the reports, first click on the link and scroll down to the 'Artifacts' section then click on 'cve_reports'."}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "*"}}}]}, {"ruleId": "a0b76f86", "message": {"text": "Product Name: avahi<br/>Version: 0.6.25<br/><br/>CVE ID: CVE-2010-2244<br/>CVE Score: 4.3<br/>CVE Severity: MEDIUM<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2010-2244<br/><br/>CVE ID: CVE-2011-1002<br/>CVE Score: 5<br/>CVE Severity: MEDIUM<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2011-1002<br/><br/>CVE ID: CVE-2017-6519<br/>CVE Score: 9.1<br/>CVE Severity: CRITICAL<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2017-6519<br/><br/>CVE ID: CVE-2021-3468<br/>CVE Score: 5.5<br/>CVE Severity: MEDIUM<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2021-3468<br/><br/>CVE ID: CVE-2021-3502<br/>CVE Score: 5.5<br/>CVE Severity: MEDIUM<br/>CVE Remark: NewFound<br/>Source: https://nvd.nist.gov/vuln/detail/CVE-2021-3502<br/><br/>CVE ID: DLA-3047-1<br/>CVE Score: unknown<br/>CVE Severity: UNKNOWN<br/>CVE Remark: NewFound<br/>Source: OSV<br/><br/>CVE ID: DLA-3414-1<br/>CVE Score: unknown<br/>CVE Severity: UNKNOWN<br/>CVE Remark: NewFound<br/>Source: OSV<br/><br/>CVE ID: DLA-3466-1<br/>CVE Score: unknown<br/>CVE Severity: UNKNOWN<br/>CVE Remark: NewFound<br/>Source: OSV<br/><br/>CVE ID: DSA-2174-1<br/>CVE Score: unknown<br/>CVE Severity: UNKNOWN<br/>CVE Remark: NewFound<br/>Source: OSV"}, "locations": [{"physicalLocation": {"artifactLocation": {"uri": "avahi-0.6.25-17.el6.x86_64.rpm.tar.gz:avahi_0.6.25"}}}]}]}]}"""
    )

    @classmethod
    def setup_class(cls):
        cls.tmp_dir = Path(tempfile.mkdtemp(prefix="cve-bin-tool-scanner-"))

    @classmethod
    def teardown_class(cls):
        shutil.rmtree(cls.tmp_dir)

    def test_generate_sarif_with_no_vulnerablities(self):
        no_vulnerabilities_json = (
            Path("test") / "sample_reports" / "no_vulnerabilities.json"
        )
        sarif_generator = generate_sarif.GenerateSarif(
            repository="repository",
            action_run_id="1",
            json_file_path=no_vulnerabilities_json,
            available_fixes={},
        )
        sarif_generator.write_file(self.tmp_dir / "output.sarif")
        with open(self.tmp_dir / "output.sarif") as fd:
            sarif_output_json = json.loads(fd.read())
            assert sarif_output_json["$schema"] == self.NO_CVE_SARIF_OUTPUT["$schema"]
            assert sarif_output_json["version"] == self.NO_CVE_SARIF_OUTPUT["version"]
            assert (
                sarif_output_json["runs"][0]["tool"]["driver"]["name"]
                == self.NO_CVE_SARIF_OUTPUT["runs"][0]["tool"]["driver"]["name"]
            )
            assert (
                sarif_output_json["runs"][0]["tool"]["driver"]["rules"]
                == self.NO_CVE_SARIF_OUTPUT["runs"][0]["tool"]["driver"]["rules"]
            )
            assert (
                sarif_output_json["runs"][0]["results"]
                == self.NO_CVE_SARIF_OUTPUT["runs"][0]["results"]
            )
        (self.tmp_dir / "output.sarif").unlink()

    def test_generate_sarif_with_vulnerablities(self):
        no_vulnerabilities_json = (
            Path("test") / "sample_reports" / "with_vulnerabilities.json"
        )
        sarif_generator = generate_sarif.GenerateSarif(
            repository="repository",
            action_run_id="1",
            json_file_path=no_vulnerabilities_json,
            available_fixes={},
        )
        sarif_generator.write_file(self.tmp_dir / "output.sarif")
        with open(self.tmp_dir / "output.sarif") as fd:
            sarif_output_json = json.loads(fd.read())
            assert sarif_output_json["$schema"] == self.WITH_CVE_SARIF_OUTPUT["$schema"]
            assert sarif_output_json["version"] == self.WITH_CVE_SARIF_OUTPUT["version"]
            assert (
                sarif_output_json["runs"][0]["tool"]["driver"]["name"]
                == self.WITH_CVE_SARIF_OUTPUT["runs"][0]["tool"]["driver"]["name"]
            )

            assert compare_dict_list(
                self.WITH_CVE_SARIF_OUTPUT["runs"][0]["tool"]["driver"]["rules"],
                sarif_output_json["runs"][0]["tool"]["driver"]["rules"],
            )
            assert compare_dict_list(
                self.WITH_CVE_SARIF_OUTPUT["runs"][0]["results"],
                sarif_output_json["runs"][0]["results"],
            )
        (self.tmp_dir / "output.sarif").unlink()
