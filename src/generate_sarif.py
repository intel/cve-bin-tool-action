# Copyright (C) 2023 Intel Corporation
# SPDX-License-Identifier: GPL-3.0-or-later

import hashlib
import json
import subprocess
from pathlib import Path

ROOT = Path(__file__).parent.parent
SARIF_TEMPLATE_FILE = ROOT / "template" / "sarif.json"


class GenerateSarif:
    def __init__(
        self, repository, action_run_id, json_file_path, html_file_path, available_fixes
    ) -> None:
        self.repository = repository
        self.action_run_id = action_run_id
        self.available_fixes = available_fixes
        self.json_file_path = Path(json_file_path).absolute()
        self.sarif_file = {}
        self.vulnerabilities = []
        self.load_sample_sarif_file()
        self.set_cve_bin_tool_version()
        if self.check_cves_in_json():
            if Path(html_file_path).exists():
                self.add_report_result()
            self.extract_vulnerablities_from_json()
            self.update_sarif_with_vulnerbilities()

    def load_sample_sarif_file(self):
        with open(SARIF_TEMPLATE_FILE) as fd:
            self.sarif_file = json.load(fd)

    def set_cve_bin_tool_version(self):
        cve_bin_tool_version = (
            subprocess.check_output(["cve-bin-tool", "--version"])
            .strip()
            .decode("utf-8")
        )
        self.sarif_file["runs"][0]["tool"]["driver"][
            "semanticVersion"
        ] = cve_bin_tool_version

    def add_report_result(self):
        report_result = {
            "ruleId": "@cve-bin-tool/html_pdf_sbom_report",
            "message": {
                "text": f"Here is the HTML, PDF & SBOM Scan Reports: https://github.com/{self.repository}/actions/runs/{self.action_run_id}. To download the reports, first click on the link and scroll down to the 'Artifacts' section then click on 'cve_reports'."
            },
            "locations": [{"physicalLocation": {"artifactLocation": {"uri": "*"}}}],
        }
        self.sarif_file["runs"][0]["results"].append(report_result)

    def set_output(self, output):
        if Path(output).is_dir():
            output_file = Path(output) / "scan-report.sarif"
        else:
            if output.endswith(".sarif"):
                output_file = Path(output)
            else:
                output_file = Path(f"{output}.sarif")
        return output_file

    def write_file(self, output_file):
        output_file = self.set_output(str(output_file))
        with open(output_file, "w+") as fd:
            fd.write(json.dumps(self.sarif_file))

    def check_cves_in_json(self):
        if not self.json_file_path.is_file():
            return False
        with open(self.json_file_path) as fp:
            json_data = json.load(fp)
        return bool(len(json_data))

    def extract_vulnerablities_from_json(self):
        self.vulnerabilities = {}
        with open(self.json_file_path) as fp:
            vulnerabilities = json.load(fp)
        for vulnerability in vulnerabilities:
            filename = vulnerability["paths"].split(" contains ")[0]
            version_tag = f'{vulnerability["product"]}_{vulnerability["version"]}'
            if filename not in self.vulnerabilities:
                self.vulnerabilities[filename] = {}
            if version_tag not in self.vulnerabilities[filename]:
                self.vulnerabilities[filename][version_tag] = {
                    "cves": [],
                    "type": vulnerability["type"],
                }
            self.vulnerabilities[filename][version_tag]["product"] = vulnerability[
                "product"
            ]
            self.vulnerabilities[filename][version_tag]["version"] = vulnerability[
                "version"
            ]
            cve_link = vulnerability["source"]
            if vulnerability["cve_number"].find("CVE") != -1:
                cve_link = (
                    f"https://nvd.nist.gov/vuln/detail/{vulnerability['cve_number']}"
                )
            available_fix = None
            if vulnerability["cve_number"] in self.available_fixes:
                available_fix = self.available_fixes[vulnerability["cve_number"]][
                    "fixed_release"
                ]
            self.vulnerabilities[filename][version_tag]["cves"].append(
                {
                    "cve_remark": vulnerability["remarks"],
                    "cve_id": vulnerability["cve_number"],
                    "cve_score": vulnerability["score"],
                    "cve_severity": vulnerability["severity"],
                    "cve_summary": vulnerability["description"],
                    "cve_link": cve_link,
                    "available_fix": available_fix,
                }
            )

    def update_sarif_with_vulnerbilities(self):
        for vulnerability in self.vulnerabilities:
            product = ""
            text = ""
            help_text = ""
            highest_score = 0
            for product in self.vulnerabilities[vulnerability]:
                text += f"Product Name: {self.vulnerabilities[vulnerability][product]['product']}<br/>Version: {self.vulnerabilities[vulnerability][product]['version']}<br/><br/>"
                for cve in self.vulnerabilities[vulnerability][product]["cves"]:
                    if cve["available_fix"]:
                        text += f"CVE ID: {cve['cve_id']}<br/>CVE Score: {cve['cve_score']}<br/>CVE Severity: {cve['cve_severity']}<br/>Patched Version: v{cve['available_fix']}<br/>CVE Remark: {cve['cve_remark']}<br/>Source: {cve['cve_link']}<br/><br/>"
                    else:
                        text += f"CVE ID: {cve['cve_id']}<br/>CVE Score: {cve['cve_score']}<br/>CVE Severity: {cve['cve_severity']}<br/>CVE Remark: {cve['cve_remark']}<br/>Source: {cve['cve_link']}<br/><br/>"
                    help_text += f"**Basic information about `{cve['cve_id']}`:**<br/>{cve['cve_summary']}<br/><br/>"
                    try:
                        if float(cve["cve_score"]) > highest_score:
                            highest_score = float(cve["cve_score"])
                    except ValueError:
                        pass
            self.sarif_file["runs"][0]["tool"]["driver"]["rules"].append(
                {
                    "id": self.hex_encode(vulnerability),
                    "shortDescription": {
                        "text": f"Vulnerable components found in {Path(vulnerability).name}",
                    },
                    "help": {"text": "", "markdown": help_text},
                    "properties": {
                        "tags": [
                            "vulnerablity",
                            self.vulnerabilities[vulnerability][product]["type"],
                        ],
                        "precision": "high",
                        "security-severity": str(highest_score),
                    },
                }
            )
            cve = {
                "ruleId": self.hex_encode(vulnerability),
                "message": {"text": text},
                "locations": [
                    {
                        "physicalLocation": {
                            "artifactLocation": {
                                "uri": str(
                                    Path(vulnerability)
                                    .absolute()
                                    .relative_to(self.json_file_path.parent)
                                )
                            }
                        }
                    }
                ],
            }
            self.sarif_file["runs"][0]["results"].append(cve)

    def hex_encode(self, string):
        encoded_string = string.encode("utf-8")
        hex = hashlib.shake_128(encoded_string).hexdigest(4)
        return hex
